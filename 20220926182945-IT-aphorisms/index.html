<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="generator" content="mkdocs-1.6.1, mkdocs-terminal-4.7.0">
    
    <meta name="description" content="My second brain, a collection of notes, thoughts, and ideas."> 
    
    <meta name="author" content="Alex Kraker"> 
    
    <link rel="canonical" href="https://kraker.github.io/notes/20220926182945-IT-aphorisms/"><link rel="icon" type="image/png" sizes="192x192" href="../img/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="../img/android-chrome-512x512.png" />
<link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png" />
<link rel="shortcut icon" type="image/png" sizes="48x48" href="../img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="../img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-32x32.png" />


    
 
<title>IT Aphorisms - notes</title>


<link href="../css/fontawesome/css/fontawesome.min.css" rel="stylesheet">
<link href="../css/fontawesome/css/solid.min.css" rel="stylesheet">
<link href="../css/normalize.css" rel="stylesheet">
<link href="../css/terminal.css" rel="stylesheet">
<link href="../css/theme.css" rel="stylesheet">
<link href="../css/theme.tile_grid.css" rel="stylesheet">
<link href="../css/theme.footer.css" rel="stylesheet">
<!-- dark color palette -->
<link href="../css/palettes/dark.css" rel="stylesheet">

<!-- page layout -->
<style>
/* initially set page layout to a one column grid */
.terminal-mkdocs-main-grid {
    display: grid;
    grid-column-gap: 1.4em;
    grid-template-columns: auto;
    grid-template-rows: auto;
}

/*  
*   when side navigation is not hidden, use a two column grid.  
*   if the screen is too narrow, fall back to the initial one column grid layout.
*   in this case the main content will be placed under the navigation panel. 
*/
@media only screen and (min-width: 70em) {
    .terminal-mkdocs-main-grid {
        grid-template-columns: 4fr 9fr;
    }
}</style>



     
    
    

    
    <!-- search css support -->
<link href="../css/search/bootstrap-modal.css" rel="stylesheet">
<!-- search scripts -->
<script>
    var base_url = "..",
    shortcuts = "{}";
</script>
<script src="../js/jquery/jquery-1.10.1.min.js" defer></script>
<script src="../js/bootstrap/bootstrap.min.js" defer></script>
<script src="../js/mkdocs/base.js" defer></script>
    
    
    
    
    <script src="../search/main.js"></script>
    

    
</head>

<body class="terminal"><div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div id="mkdocs-terminal-site-name" class="logo terminal-prompt"><a href="https://kraker.github.io/notes/" class="no-style">notes</a></div>
        </header>
        
        <nav class="terminal-menu">
            
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href="../home/" class="menu-item " property="item" typeof="WebPage">
                        <span property="name">/home</span>
                    </a>
                    <meta property="position" content="0">
                </li>
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href=".." class="menu-item " property="item" typeof="WebPage">
                        <span property="name">/index</span>
                    </a>
                    <meta property="position" content="1">
                </li>
                
                    
                    


<li property="itemListElement" typeof="ListItem">
    <a href="#" class="menu-item" data-toggle="modal" data-target="#mkdocs_search_modal" property="item" typeof="SearchAction">
        <i aria-hidden="true" class="fa fa-search"></i> <span property="name">Search</span>
    </a>
    <meta property="position" content="2">
</li>
                    
            </ul>
            
        </nav>
    </div>
</div>
        
    <div class="container">
        <div class="terminal-mkdocs-main-grid"><aside id="terminal-mkdocs-side-panel"><nav>
  
    <ul class="terminal-mkdocs-side-nav-items">
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../home/">/home</a>
        
    
    
    
  </li>
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="..">/index</a>
        
    
    
    
  </li>
        
    </ul>
  
</nav><hr>
<nav>
    <ul>
        <li><a href="#it-aphorisms">IT Aphorisms</a></li>
        <li><a href="#on-project-manglement">On project manglement</a></li><li><a href="#inalienable-truths">Inalienable Truths</a></li><li><a href="#human-centered-issues">Human-centered "issues"</a></li><li><a href="#on-the-unreasonable-usefulness-of-documentation">On the unreasonable usefulness of documentation</a></li><li><a href="#getting-to-the-root-of-the-problem">Getting to the "root" of the problem</a></li><li><a href="#theory-of-knowledge-aka-learning">Theory of knowledge (aka learning)</a></li><li><a href="#security">Security</a></li>
    </ul>
</nav>
</aside>
            <main id="terminal-mkdocs-main-content">
<section id="mkdocs-terminal-content">
    <h1 id="it-aphorisms">IT Aphorisms<a class="headerlink" href="#it-aphorisms" title="Permanent link">#</a></h1>
<p>Aphorisms on IT, problem solving, and related.</p>
<h2 id="on-project-manglement">On project manglement<a class="headerlink" href="#on-project-manglement" title="Permanent link">#</a></h2>
<p><strong>The scope <em>is</em> the project.</strong></p>
<p><em>Or, do you even know what your project is, if you haven't scoped it?</em></p>
<p>Failure to scope your project adequately will result in failure to deliver said project. A poorly defined scope or project description that's chock-full of buzzwords is vague enough as to be virtually useless (i.e. limitless or <em>without scope</em>). There's no way to <em>complete</em> a project with no clearly defined scope because there's no way to reasonable be able to say when it's "done." Define the scope and you've defined the project. Said in other words, if you don't have a clearly defined scope what you have is an "idea" not a project. This is also why many people have a "million dollar idea" but they need a "technical co-founder" to bring it to fruition. They have failed to define a scope and therefore a project. Adequately scoping a project requires technical knowledge and domain experience, and the effort involved shouldn't be taken lightly. This may in fact be <em>more than half the battle</em> when it comes to completing a project.</p>
<p><strong>Non-technical PM's who are also poor managers are worse than no manager at all when it comes to technical projects.</strong></p>
<p><em>There I said it. But also, if you're not technical and you're also not a good manager, what business do you have managing a technical project?</em></p>
<p>Non-technical PM's who are also poor managers are worse than no manager at all. Non-technical PM's who are good managers are slightly better than no manager at all as they can act as a "buffer" between the customer and the IT professional and perform a "diplomatic function". (see runaway problem cascades, below). Best is a PM who's both technical and possesses adequate people skills to interface with the customer. This is understandably rare and worth every penny (although C-levels rarely seem to see it this way). It's difficult to apply <em>quality control</em> to a project without a technical PM. </p>
<h3 id="projects-must-be-rooted-in-reality">Projects must be rooted in "reality"<a class="headerlink" href="#projects-must-be-rooted-in-reality" title="Permanent link">#</a></h3>
<p><em>I feel like this shouldn't need to be said, but experience dictates otherwise...</em></p>
<p><strong>Projects must obey the physical laws of the universe.</strong></p>
<p><strong>Projects must be rooted in <em>reality</em></strong> </p>
<p>This means first and foremost obeying the <em>physical laws of the universe.</em> This includes the laws of thermodynamics and therefore no project is immune to <em>entropy</em>. Therefore, bugs are inevitable. If bugs could be predicted and mitigated that would mean time-travel is possible, and this breaks all of the known laws of the universe! Customers who expect this, are dilusional and need to be "educated" (see below).</p>
<p><strong>Complexity is the devil and is best avoided if at all possible.</strong></p>
<p>Unfortunately, some complexity is necessary. Efforts to reduce complexity and provide simple clear and ledgible solutions is honorable and deserves more recognition than it seems to get.</p>
<p>The difficulty in producing a simple universal solution to a class of problems should not be underestimated. Depending on how universal the solution, this can literally be a "work of genius." Einsteins general theory of relativity is an example of a simple solution to a universal class of problems that was literally a work of genius. </p>
<h2 id="inalienable-truths">Inalienable Truths<a class="headerlink" href="#inalienable-truths" title="Permanent link">#</a></h2>
<p>Something must serve as the single source of truth. Always. It doesn't necessarily matter what it is, but it must exist. Everything else should be treated as "fiction". </p>
<p>If it's not a ticket, it's not getting done.</p>
<p>Just because it's a ticket doesn't mean that it's a problem that needs to be solved. (See law of parsimony below)</p>
<p>Not solving a problem can be a valid solution. It's always worth consideration.</p>
<p>Time spent in meetings is inversely correlated with productivity. </p>
<p>Computers do everything you tell them to <em>exactly</em> as they're told, nothing more nothing less. </p>
<p><strong>Do things the "right" way the first time.</strong></p>
<p>There's usually a "right" way to do something, or at least a "more right" way to do something. It's many orders of magnitude easier and faster to do something right the first time than it is to try to fix it later (if it's even possible to fix it later). Alongside lack of documentation this may be the 2nd most abundant reason for "technical debt". </p>
<p>DNS is almost always the issue. </p>
<p>Most developers and software admins don't truly understand DNS. </p>
<p>Any developer who understands DNS and networking is actually "DevOps" despite what their title might say. </p>
<h2 id="human-centered-issues">Human-centered "issues"<a class="headerlink" href="#human-centered-issues" title="Permanent link">#</a></h2>
<p>Communication overhead grows exponentially in relation to the number of people on a team. There's a point beyond which no useful production occurs beyond maintaining the status quo. If combined with mis-management it's in-fact possible to move backwards on a project under certain circumstances. </p>
<p>Knowledge work is non-linear and hours in doesn't equal hours out in terms of production. At the extreme end of performance knowledge work is more like being an athlete. Top chess grandmasters is a case in point.  </p>
<p>Productivity obey's the <em>pareto principle</em> in that 80% of the work is being done by 20% of the workers. This an immutable law of the universe. You might as well use the 80% of your work-force to do menial tasks to free up your top 20% of performers to do their best work. Nobody manages their work this way though, because "fairness" and "equality" usually plays a part. Optimizing for productivity above all else would look a lot different. </p>
<p>Attitude is more than half the battle. </p>
<h3 id="sub-class-of-humans-known-as-customers">Sub-class of humans known as "customers"<a class="headerlink" href="#sub-class-of-humans-known-as-customers" title="Permanent link">#</a></h3>
<p>Customers are often wrong and if not handled carefully may introduce more technical debt, burry techs in "non-problems", or result in more communication overhead than can be reasonably managed by the IT resources available. If left completely unchecked this could easily result in a runaway problem cascade that can't be resolved with the IT-resources available in the known universe.</p>
<p>Educating the customer must be achieved "diplomatically" or the IT professional may find themselves saddled with "financial" problems instead of our preferred "technical" ones. </p>
<p>There exists space in a venn-diagram of customer "asks" and "solvable problems" that's neither the "most right" solution or impossible. This is a balance that must be delicately maintained. (see runaway problem cascade above)</p>
<h2 id="on-the-unreasonable-usefulness-of-documentation">On the unreasonable usefulness of documentation<a class="headerlink" href="#on-the-unreasonable-usefulness-of-documentation" title="Permanent link">#</a></h2>
<p><strong>Understanding undocumented systems is an art, but more importantly a "science."</strong></p>
<p><strong>Doing "science" as an IT professional is not necessarily a <em>good thing.</em></strong></p>
<p>If it's not documented somewhere, "science" must be conducted to understand the system through rigorous positing of hypothesis and developing models (i.e. theories) via testing, and observation. Only once concrete evidence is obtained through observational tools and a useful <em>model</em> developed (i.e. theory) can the system be reliably fixed when it inevitably breaks. This is an arduous, time-consuming, and inefficient process. It's often many orders of magnitude less-effort to rebuild the system, documenting as you go, than it is to try to understand an undocumented system that already exists. This is the origins of most "technical debt."</p>
<p>Lack of documentation is probably the single greatest source of "technical debt" beyond poor design or development choices.</p>
<p>Documentation is a moral obligation to your fellow IT professionals. It's unequivocally ethically "good" to write documentation and worse than mere laziness but for all intents and purposes "evil" to fail to produce adequate documentation alongside delivery of any sort of developed system, body of work, coded project, or other necessarily complex system. Not only will future techs thank you, but your future self will thank you as well. It's irrational to assume your memory is as good as you think it is and that you won't refer to your own carefully crafted docs 6-months from now. </p>
<p>Visual aids such as lovingly crafted network diagrams are a love-letter to future sysadmins. This is the art of documentation. It's intrinsically good to produce this form of documentation even if nobody ever see's it other than you. </p>
<p>Failure to document is failure to embue your thing with enough evolutionary relevance to survive the first iteration of said thing. It will cease to exist beyond it's first iteration since it will be too difficult to understand and it will instead be replaced by a newer heartier version of the thing. The only exceptions are a thing that's so business useful it's worth infusing inordinate amounts of resources (money) to "life-support" said thing, but even these systems eventually are overcome. </p>
<h2 id="getting-to-the-root-of-the-problem">Getting to the "root" of the problem<a class="headerlink" href="#getting-to-the-root-of-the-problem" title="Permanent link">#</a></h2>
<p><strong>Context is everything.</strong></p>
<p>Problems don't exist outside of the context they live in. Failure to provide context is failure to provide a problem rooted in reality. Problems not rooted in reality are fictitious and not real problems. (See laws of physics above)</p>
<p><strong>A well-defined problem is a solvable problem.</strong></p>
<p>You can't solve the problem before defining the problem in concrete terms. If you can't define the problem in concrete terms you don't understand enough about the system to define it. If you don't understand the system, either read the docs or if those don't exist, do more "science" (see above) to understand the problem space. Apprenticeship from a wizard is the only "short-cut" to RTFM and/or doing "science". But it's not a substitute for those two things and should be used sparingly. </p>
<p><strong>Accurately defining the problem is more than half the battle.</strong></p>
<p>Sometimes if you try to formulate your problem in such a way that you can describe it to someone else you'll solve your own problem. This is because you've only now "defined your problem in concrete terms" (see above). Reaching out to others and formulating your problem is a valid problem solving method. </p>
<p><strong>Problems are only truly resolved from at the root.</strong></p>
<p>Solve <em>root issues</em> not <em>symptoms</em>. Solving symptoms is little better than a "bandaid" in most cases, and in some cases creates more "problems" to be solved. The only right solution is solving the root issue. QED</p>
<h3 id="the-law-of-parsimony-and-problem-solving">The law of parsimony and problem solving.<a class="headerlink" href="#the-law-of-parsimony-and-problem-solving" title="Permanent link">#</a></h3>
<p>The simplest solution is almost always the best solution. The absolute simplest solution is no solution at all.  For this reason, it's worth putting serious thought into if your thing should exist at all. After all, existence creates problems that then need to be solved. Entropy dictates this. </p>
<h3 id="on-the-observability-of-problems">On the observability of problems<a class="headerlink" href="#on-the-observability-of-problems" title="Permanent link">#</a></h3>
<p><em>AKA quantum problems</em></p>
<p>Some problems are in a special class of problems analagous to quantum particles in that observation of the problem affects the problem itself. You can know either a particle's position or velocity, but not both. Observation of the problem will change the nature of the problem. The good news is the solution is usually <em>static</em> even if observations are subject to change. The wise sysadmin knows this, and is thus unsurprised when different observational tools produce different results for the same problems. Only through testing and continued observation can the problem space converge towards a "limit." Using the calculus analogy most problems <em>converge</em>, but some classes of problems (i.e. impossible problems) <em>diverge</em>. Experience is required to identify <em>divergent</em> probems, and mastery required to be able to set aside such problems. </p>
<p><strong>Don't go looking for problems.</strong></p>
<p>In a similar fashion, some problems don't exist until they are observed. These are the "if a tree falls in the forest but no one is there to hear it, does it make a sound?" class of problems. For this reason it's important to make sure that monitoring and alerting tools are calibrated effectively such that you're not creating a limitless supply of "problems" for yourself and your team. Problems are literally <em>infinite</em> if you look hard enough, but the solution space is for all practical purposes <em>finite.</em></p>
<p><strong>Triage problems ruthlessly or forever be chasing the receding horizon that is your problem set.</strong></p>
<p>Triaging problems is essential. Some problems are not really problems in that the system is robust enough to survive uncritical "issues", in many cases indefinitely. Given this, are they really problems? Other problems kill the host and should be treated with utmost urgency. Most problems are somewhere in-between these two extremes.  </p>
<h3 id="premature-optimization">Premature optimization<a class="headerlink" href="#premature-optimization" title="Permanent link">#</a></h3>
<p>Performance optimization is a class of problems that may be both uncritical or critical depending on the context. At some point performance optimization becomes "yak shaving" and is best avoided. </p>
<h3 id="fear-of-failure">Fear of failure<a class="headerlink" href="#fear-of-failure" title="Permanent link">#</a></h3>
<p>Backups are only as valuable as the regular testing and documentation of your <em>disaster recovery</em> solution. Without testing, your backup solution is little more than worthless. </p>
<p>HA is only as good as it's implementation and in practice only as good as the sysadmins maintaining it. Overly complex or difficult to maintain HA systems may in fact be less reliable and result in more downtime in practice than a single monolithic system. Think carefully before introducing this level of complexity to your system. HA is by no means a silver-bullet and should be implemented sparingly. An undocumented HA solution may as well not exist. Anybody who asks for HA as a solution to the class of "all problems resulting in downtime" doesn't truly understand HA. (See educating the customer above)</p>
<p>DR tests don't always go according to plan, that's why they're called DR "tests". If a customer gets upset when a DR test doesn't go according to plan they need to be "educated" (see human problems above). </p>
<h2 id="theory-of-knowledge-aka-learning">Theory of knowledge (aka learning)<a class="headerlink" href="#theory-of-knowledge-aka-learning" title="Permanent link">#</a></h2>
<p>If don't truly "know" something until you can describe it in a way that a 5 year old can understand. </p>
<p>You don't really understand something until you can build something with it. </p>
<h3 id="learning-vs-education">Learning vs. "Education"<a class="headerlink" href="#learning-vs-education" title="Permanent link">#</a></h3>
<p><strong>There's no substitute for experience.</strong></p>
<p>You can't learn how to be a developer/sysadmin/devops in a 12-week bootcamp, despite marketing to the contrary. You can, however, get a job after, and then "learn" those things. </p>
<p>Formal education in computer science is weakly correlated with future success in the field, if it's correlated at all. It could be argued that IT is really more of an "apprenticeship" and for most practical purposes it's best approached with "hands-on" learning. </p>
<p><strong>Certs are resume builders.</strong></p>
<p>IT certificates are little better than bullet points on a resume that get your foot in the door with recruiters. Most IT professionals could care less and the proof is the the pudding so-to-speak. It's possible to study for the test and not really understand a lot of what you "learned." It's even more common to cram for the test and forget 90% of what you learned.The only exception is skills learned in a lab that closely approximates real-life scenarios.  We only care about the skills you can demonstrate and being able to solve real problems in the field. Willingness to learn, attitude, and analytical thinking skills are far more important than any certification. It's your <em>approach</em> to a problem that's unfamiliar to you that's much more important than whether or not you get the right answer at least as far as interviewing is concerned. </p>
<h3 id="how-to-learn">How to learn<a class="headerlink" href="#how-to-learn" title="Permanent link">#</a></h3>
<p><strong>Learn by doing is best.</strong></p>
<p>Portfolio projects are a much better indicator of true skills and knowledge. </p>
<p>Project-based learning that solves real-world problems is the best way to learn IT skills. The best lab for the IT professional is the homelab.  The monetary investment in a homelab is completely dwarfed by future salary compensation. In the long-term it's a negligible expense. </p>
<p>If you're not interested in building a homelab and learning in your off-hours, seriously reconsider whether or not this is the right field for you. It's difficult to progress (at least at first) without a natural affinity for learning and being driven by curiosity. Later in your career you may be able to afford to "rest on your laurels" and coast in your career. But expect to put a significant amount of free-time towards learning and skills acquisition your first few years. </p>
<h2 id="security">Security<a class="headerlink" href="#security" title="Permanent link">#</a></h2>
<p>People are usually the weakest link when it comes to security. </p>
</section>

            </main>
        </div>
        <hr><footer>
    <div class="terminal-mkdocs-footer-grid">
        <div id="terminal-mkdocs-footer-copyright-info">
            
            <p class="text-center text-muted">Copyright © 2025 Alex Kraker</p>
             Site built with <a href="http://www.mkdocs.org">MkDocs</a> and <a href="https://github.com/ntno/mkdocs-terminal">Terminal for MkDocs</a>.
        </div>
    </div>
</footer>
    </div>

    
    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="alertdialog" aria-modal="true" aria-labelledby="searchModalLabel">
    <div class="modal-dialog modal-lg" role="search">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="searchModalLabel">Search</h5>
                <button type="button" class="close btn btn-default btn-ghost" data-dismiss="modal"><span aria-hidden="true">x</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p id="searchInputLabel">Type to start searching</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" aria-labelledby="searchInputLabel" placeholder="" id="mkdocs-search-query" title="Please enter search terms here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No document matches found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    
    
</body>

</html>